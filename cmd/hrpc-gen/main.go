// Copyright 2020 Eryx <evorui at gmail dot com>, All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	strSpaceReg     = regexp.MustCompile("\\ +")
	codeCommentsReg = regexp.MustCompile(`/\*(.*?)\*/`)
)

func main() {

	protoPath := "*.proto"
	if len(os.Args) > 1 {
		protoPath = os.Args[1]
	}

	fmt.Println("gen", protoPath)

	ls, err := filepath.Glob(protoPath)
	if err != nil {
		log.Fatal(err)
	}

	for _, vfile := range ls {
		if err := protoAction(vfile); err != nil {
			fmt.Println("ERROR", vfile, err.Error())
		}
	}
}

type serviceEntry struct {
	name    string
	methods []methodEntry
}

type methodEntry struct {
	method  string
	request string
	reply   string
}

func protoAction(file string) error {

	fp, err := os.Open(file)
	if err != nil {
		return err
	}
	defer fp.Close()

	fpbuf := bufio.NewReader(fp)

	var (
		list    []*serviceEntry
		entry   *serviceEntry
		pkgname = ""
	)

	for {

		bs, err := fpbuf.ReadBytes('\n')
		if err != nil {
			break
		}

		str := strSpaceReg.ReplaceAllString(
			strings.TrimSpace(strings.Replace(string(bs), "\t", " ", -1)), " ")
		str = codeCommentsReg.ReplaceAllString(str, "")

		if strings.HasPrefix(str, "}") {

			if entry != nil && entry.name != "" && len(entry.methods) > 0 {
				list = append(list, entry)
			}
			entry = nil
			continue

		} else if strings.HasPrefix(str, "service") {

			if entry != nil && entry.name != "" && len(entry.methods) > 0 {
				list = append(list, entry)
			}

			entry = &serviceEntry{
				name: strings.TrimSpace(str[7 : len(str)-1]),
			}
			continue
		} else if strings.HasPrefix(str, "package") {
			if i := strings.Index(str, ";"); i > 0 {
				pkgname = strings.TrimSpace(str[7:i])
			}
			continue
		}

		if entry == nil {
			continue
		}

		ps := strings.Split(str, " ")
		if len(ps) < 3 {
			continue
		}

		switch ps[0] {
		case "rpc":

			if len(ps) == 6 {

				var (
					methodName = ps[1]
					reqName    = strings.Replace(strings.Replace(ps[2], "(", "", 1), ")", "", 1)
					repName    = strings.Replace(strings.Replace(ps[4], "(", "", 1), ")", "", 1)
				)

				entry.methods = append(entry.methods, methodEntry{
					method:  methodName,
					request: reqName,
					reply:   repName,
				})
			}
		}
	}

	if entry != nil && entry.name != "" && len(entry.methods) > 0 {
		list = append(list, entry)
	}

	if pkgname == "" || len(list) == 0 {
		return nil
	}

	filename := file
	if i := strings.LastIndex(filename, "/"); i > 0 {
		filename = filename[i+1:]
	}

	code := "// Code generated by github.com/hooto/hrpc4g\n"
	code += fmt.Sprintf("// source: %s\n// DO NOT EDIT!\n", filename)
	code += "\npackage " + pkgname + "\n\n"
	code += "import \"context\"\n\n"
	code += "import \"github.com/golang/protobuf/proto\"\n"
	code += "import \"github.com/hooto/hrpc4g/hrpc\"\n"

	for _, v := range list {

		if v.name == "" {
			continue
		}

		if len(v.methods) < 1 {
			continue
		}

		//
		code += fmt.Sprintf("\ntype Hrpc%sClientInterface interface {\n", v.name)
		for _, v2 := range v.methods {
			code += fmt.Sprintf("\t%s(ctx context.Context, in *%s) (*%s, error)\n",
				v2.method, v2.request, v2.reply)
		}
		code += "}\n\n"

		//
		code += fmt.Sprintf("type hrpc%sClient struct {\n\tc *hrpc.Client\n}\n\n", v.name)

		for _, v2 := range v.methods {
			code += fmt.Sprintf(`func (c *hrpc%sClient) %s(ctx context.Context, in *%s) (*%s, error) {
	out := new(%s)
	err := c.c.Invoke(ctx, "%s.%s/%s", in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

`,
				v.name, v2.method, v2.request, v2.reply,
				v2.reply,
				pkgname, v.name, v2.method,
			)
		}

		//
		code += fmt.Sprintf(`func Hrpc%sClient(c *hrpc.Client) Hrpc%sClientInterface {
	return &hrpc%sClient{
		c: c,
	}
}

`,
			v.name, v.name, v.name)

		//

		code += fmt.Sprintf(`var Hrpc%sServiceDesc = &hrpc.ServiceDesc{
	ServiceName: "%s.%s",
	HandlerType: (*%sServer)(nil),
	Methods: []hrpc.ServiceMethodDesc{
`,
			v.name,
			pkgname, v.name,
			v.name)
		for _, v2 := range v.methods {
			code += "\t\t{\n"
			code += fmt.Sprintf("\t\t\tMethodName: \"%s\",\n", v2.method)
			code += fmt.Sprintf("\t\t\tHandler:    hrpc_%s_%s_Handler,\n", v.name, v2.method)
			code += "\t\t},\n"
		}
		code += "\t},\n}\n\n"

		//
		for _, v2 := range v.methods {
			code += fmt.Sprintf(`func hrpc_%s_%s_Handler(srv interface{}, ctx context.Context, inb []byte) (proto.Message, error) {
	in := new(%s)
	if err := proto.Unmarshal(inb, in); err != nil {
		return nil, err
	}
	return srv.(%sServer).%s(ctx, in)
}

`,
				v.name, v2.method,
				v2.request,
				v.name, v2.method)
		}

	}

	//
	fileout := file
	if strings.HasSuffix(fileout, ".proto") {
		fileout = fileout[:len(fileout)-6]
		fileout += ".hrpc.go"

		fpo, err := os.OpenFile(fileout, os.O_RDWR|os.O_CREATE, 0644)
		if err != nil {
			return err
		}
		fpo.Seek(0, 0)
		fpo.Truncate(0)

		fpo.WriteString(strings.TrimRight(code, "\n"))
		fpo.Close()
		fmt.Println("OK", fileout)
	}

	return nil
}
